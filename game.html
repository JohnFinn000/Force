<!DOCTYPE html>
<html>
<head>
<table border="1">
<tr>
<td>
<div>
<canvas id="view_surface" width="1000" height="800" >
</canvas>
</div>
</td>
<td>
<div id = "console"> nothing </div>
</td>
<td>
<div id = "collider"> </div>
</td>
<tr>
</table>
<script type="text/javascript">

var surface;
var ctx;
var color;

var interval = .01; // a tenth of a second
var WIDTH = 1000;
var HEIGHT = 800;
var gravity = 50;
var wind_resistance = 0;


var world = new Array();
var fac = new factory();
var collider = new BVH( );
var user;
var up    = 38;
var left  = 37;
var right = 39;
var down  = 40;

function init() {
	surface = document.getElementById( "view_surface" );
	ctx = surface.getContext("2d");
	color = "red";
	user = fac.spawn( 100, 100 );
	fac.spawn( 200, 200 );
	fac.spawn( 300, 100 );
	fac.spawn( 400, 200 );
	fac.spawn( 500, 100 );
	fac.spawn( 610, 200 );
	fac.spawn( 707, 100 );
	fac.spawn( 810, 200 );
	fac.spawn( 860, 100 );
	fac.spawn( 157, 241 );
	//fac.spawn( 252, 280 );
	//fac.spawn( 355, 241 );
	//fac.spawn( 153, 325 );
	/*fac.spawn( 253, 533 );
	fac.spawn( 353, 143 );
	fac.spawn( 753, 133 );
	fac.spawn( 406, 102 );
	fac.spawn( 101, 202 );
	fac.spawn( 272, 274 );
	fac.spawn( 375, 275 );
	fac.spawn( 176, 381 );
	fac.spawn( 279, 609 );
	fac.spawn( 385, 189 );
	fac.spawn( 792, 299 );
	fac.spawn( 487, 246 );
	fac.spawn( 174, 274 );
	fac.spawn( 274, 279 );
	fac.spawn( 373, 273 );
	fac.spawn( 173, 376 );
	fac.spawn( 273, 576 );
	fac.spawn( 372, 173 );
	fac.spawn( 771, 172 );*/
	return setInterval( cycle, 1000*interval );
}

function trigger_up() {
	user.push( 0, -50, "up" );
}

function trigger_left() {
	user.push( -50, 0, "left" );
}

function trigger_right() {
	user.push( 50, 0, "right" );
}

function trigger_down() {
	user.push( 0, 50, "down" );
}

function clear() {
	ctx.clearRect( 0, 0, WIDTH, HEIGHT );
}

function cycle() {
	move();
	draw();
}

function move() {
	for( var i in world ) {
		if( world[i] ) {
			world[i].move();
		}
	}
}

function draw() {
	clear();
	document.getElementById("collider").innerHTML="" + bvh_height +"<br>";
	collider.draw();
	var str = "";
	for( var i in world ) {
		if( world[i] ) {
			str += "(" + world[i].x +", " + world[i].y +")" + "<br>";
			world[i].draw();
		}
	}
	document.getElementById("console").innerHTML=str;
}

function do_key_down( evt ) {
	evt = evt || window.event;
	var key = evt.which || evt.keyCode;

	if( key == up ) {
		trigger_up();
	} else if( key == left ) {
		trigger_left();
	} else if( key == right ) {
		trigger_right();
	} else if( key == down ) {
		trigger_down();
	}

}

function do_key_press( evt ) {
/*
	evt = evt || window.event;
	var key = evt.which || evt.keyCode;

	color = "blue";
	if( key == up ) {
		trigger_left();
	} else if( key == left ) {
		trigger_up();
	} else if( key == right ) {
		trigger_right();
	} else if( key == down ) {
		trigger_down();
	}
*/
}

function do_mouse_down( evt ) {

}

function do_mouse_move( evt ) {

}

function do_mouse_up( evt ) {

}

function factory() {

	this.spawn = spawn;
	function spawn( x, y ) {
		var index = world.length;
		world.push( index );
		world[index] = new mobile( x, y );
		collider.new_shape( world[index] );
		return world[index];	
	}
}

var bvh_height = 0;

function BVH( ) {
	this.x = 0;
	this.y = 0;
	this.x_size = 0;
	this.y_size = 0;
	this.depth = 0;
	this.max_children = 5;
	this.min_children = 2;
	this.children = new Array();
	this.ancestor = this;
	this.link;
	this.remove_me = 0;


	this.fit = fit;
	this.new_shape = new_shape;
	this.insert = insert;
	this.add = add;
	this.split = split;
	this.join = join;
	this.draw = draw;
	this.remove = remove;
	this.adjust = adjust;
	this.distance_squared = distance_squared;
	this.get_volume = get_volume;
	this.is_full = is_full;

	// this is meant for leaf nodes
	function fit( obj ) {
		this.x = obj.x;
		this.y = obj.y;
		this.x_size = obj.x_size;
		this.y_size = obj.y_size;
	}

	function new_shape( obj ) {
		var n = new BVH();
		n.fit( obj );
		n.link = obj;
		obj.bvh = n;
		this.insert( n );
	}

	// adds the new obj into the bvh that must expand the least to fit it
	function insert( n ) {

		if( this.depth >= bvh_height ) {
			this.add( n );
		} else {

			var best_location;
			var smallest_vol = 9999999;
			for( var i in this.children ) {
				if( this.children[i] ) {
					var temp = this.children[i].get_volume( n )
					if( temp == 0 ) {
						this.children[i].insert( n );
					} else if( temp < smallest_vol ) {
						if( !best_location || !this.children[i].is_full() ) {
							best_location = this.children[i];
							smallest_vol = temp;
						}
					}
				}
			}
			if( best_location ) {
				best_location.insert( n );
			}
		}
	}

	function move() {

	}

	function add( new_member ) {

		var adjustment_required = 0;

		if( new_member.x < this.x || !this.x ) {
			this.x_size += this.x - new_member.x;
			this.x = new_member.x;
			adjustment_required = 1;
		}
		if( new_member.y < this.y || !this.y ) {
			this.y_size += this.y - new_member.y;
			this.y = new_member.y;
			adjustment_required = 1;
		}
		if( new_member.x + new_member.x_size > this.x + this.x_size ) {
			this.x_size = new_member.x + new_member.x_size - this.x;
			adjustment_required = 1;
		}
		if( new_member.y + new_member.y_size > this.y + this.y_size ) {
			this.y_size = new_member.y + new_member.y_size - this.y;
			adjustment_required = 1;
		}
		
	
		var index = this.children.length;
		if( index > this.max_children-1 ) {
			new_member.ancestor = this;
			new_member.depth = this.depth+1;
			this.children.push( index );
			this.children[index] = new_member;
			this.split();
		} else {
			new_member.ancestor = this;
			new_member.depth = this.depth+1;
			this.children.push( index );
			this.children[index] = new_member;
		}
		
		if( adjustment_required != 0 ) {
			this.adjust();
		}
	}

	function split() {

		if( this.depth == 0 ) {	
			++bvh_height;	
		}

		var old_children = this.children.concat();
		//this.children.splice(1, this.children.length );
		while( this.children.pop() );
		var str = "";
		
		var worst_pair;
		for( var a in old_children ) {
			for( var i in old_children ) {
				if( old_children[a] && old_children[i] ) {
					new_pair = new pair(old_children[a],old_children[i]);
					if( !worst_pair ) {
						worst_pair = new_pair;
					} else {
						if( new_pair.volume > worst_pair.volume ) {
							worst_pair = new_pair;
						}
					}
				}
			}
		}

		this.remove_me = 1;
		this.ancestor.remove();

		var worst_a = new BVH();
		worst_a.fit( worst_pair.a );
		worst_a.add( worst_pair.a );
		this.ancestor.add( worst_a );

		var worst_b = new BVH();
		worst_b.fit( worst_pair.b );
		worst_b.add( worst_pair.b );
		this.ancestor.add( worst_b );


		// remove the worst_b and worst_a from the old_children
		for( var i in old_children ) {
			this.ancestor.insert( old_children[i] );
		}

		
		str += "<br>(" + worst_pair.a.x + ", "+worst_pair.b.x+") " + worst_pair.volume + "<br> ";
		document.getElementById("console").innerHTML+=str;
		
/*
		this.children = new_children;

		for( var i in old_children ) {
			if( old_children[i] ) {
				this.insert( old_children.pop() );
			}
		}

*/		
	}

	function join() {
		if( this.depth != 0 ) {
			//this.remove_me = 1;
			//this.ancestor.remove();
		}
	}

	function draw() {
		var str = "";
		if( this.depth == 0 ) {
			ctx.fillStyle = "#222222";
		} else if( this.depth == 1 ) {
			ctx.fillStyle = "#555555";
		} else if( this.depth == 2 ) {
			ctx.fillStyle = "#999999";
		} else {
			ctx.fillStyle = "#CCCCCC";
		}
		ctx.fillRect( this.x-1, this.y-1, this.x_size+2, this.y_size+2 );	

		ctx.fillStyle = "green";
		document.getElementById("console").innerHTML= this.depth + " " + this.x +", " + this.y +"  " +this.x_size +", " +this.y_size + "<br>";
		ctx.fillText("depth " + this.depth , this.x + (this.x_size/2), this.y - 20 );
		ctx.fillText("children " + this.children.length , this.x + (this.x_size/2), this.y - 10 );
		ctx.strokeRect( this.x-2, this.y-2, this.x_size+4, this.y_size+4 );	
		str = this.depth + " (" + this.x + ", " + this.y + ") (" + this.x_size + ", " + this.y_size + ")<br>";
		document.getElementById("collider").innerHTML+=str;
		for( var i in this.children ) {
			if( this.children[i] ) {
				this.children[i].draw();
			}
		}
	}

	function remove() {
		
		var temp_x;
		var temp_y;
		var temp_x_size;
		var temp_y_size;

		for( var i in this.children ) {
			if( this.children[i] ) {
				if( this.children[i].remove_me != 0 ) {
					temp_x = this.children[i].x;
					temp_y = this.children[i].y;
					temp_x_size = this.children[i].x_size;
					temp_y_size = this.children[i].y_size;
					this.children.splice( i, 1 );
				}			
			}
		}

		// I don't believe length will ever be 0 for this in js
		// this should actually be min_children
		if( this.children.length == 0 ) {
			join();
		}
		if( temp_x == this.x ) {
			this.adjust();
		}
		if( temp_y == this.y ) {
			this.adjust();
		}
		if( temp_x + temp_x_size == this.x + this.x_size ) {
			this.adjust();
		}
		if( temp_y + temp_y_size == this.y + this.y_size ) {
			this.adjust();
		}
	}

	function adjust() {

		var new_x;
		var new_y;
		var new_x_br = 0;
		var new_y_br = 0;
		for( var i in this.children ) {
			if( this.children[i] ) {
				if( this.children[i].x < new_x || !new_x ) {
					new_x = this.children[i].x;
				}
				if( this.children[i].y < new_y || !new_y ) {
					new_y = this.children[i].y;
				}   
				if( this.children[i].x + this.children[i].x_size > new_x_br ) {
					new_x_br = (this.children[i].x + this.children[i].x_size);
				}   
				if( this.children[i].y + this.children[i].y_size > new_y_br ) {
					new_y_br = (this.children[i].y + this.children[i].y_size);
				}
			}
		}
		this.x = new_x;
		this.y = new_y;
		this.x_size = new_x_br - new_x;
		this.y_size = new_y_br - new_y;

		// if there was to size adjustment in this box there won't need to be a size adjustment in the ancestor box
		if( this.depth != 0 ) {
			this.ancestor.adjust();
		}
	}
	// this will not return the real distance only distance^2
	// it will need to be square rooted unless just being used as a comparison

	function distance_squared( b ) {
		var distance;
		if( b.x > (b.y/2) || b.y > (b.x/2) ) { // if it’s squarish
			var b_radius = ((b.x_size/2) ^ 2) + ((b.y_size/2) ^ 2);
			var t_radius = ((this.x_size/2) ^ 2) + ((this.y_size/2) ^ 2);
			distance = (((this.x - b.x) ^ 2) + ((this.y - b.y) ^ 2)) - (t_radius + b_radius);
		} else {
			var x_diff;
			var y_diff;
			if( this.x < b.x ) {
				x_diff = (b.x - (this.x + this.x_size) );
			} else {
				x_diff = (this.x + this.x_size) - b.y;
			}

			if( this.y < b.y ) {
				y_diff = (b.y - (this.y + this.y_size) );
			} else {
				y_diff = (this.y + this.y_size) - b.y;
			}
			distance = (x_diff ^ 2) + (y_diff ^ 2)
		}
		return distance;
	}

	function get_volume( b ) {
		var new_x;
		var new_y;
		var new_x_br;
		var new_y_br;
		var new_x_size;
		var new_y_size;
		
		if( this.x < b.x ) {
			new_x = this.x;
		} else {
			new_x = b.x;
		}

		if( this.y < b.y ) {
			new_y = this.y;
		} else {
			new_y = b.y;
		}
  
		if( this.x + this.x_size > b.x + b.x_size ) {
			new_x_br = (this.x + this.x_size);
		} else {
			new_x_br = (b.x + b.x_size);
		}

		if( this.y + this.y_size > b.y + b.y_size ) {
			new_y_br = (this.y + this.y_size);
		} else {
			new_y_br = (b.y + b.y_size);
		}

		new_x_size = new_x_br - new_x;
		new_y_size = new_y_br - new_y;
/*
		var volume;
		var new_x;
		var new_y;
		var new_x_size = 0;
		var new_y_size = 0;
		if( b.x > this.x ) {
			new_x_size = (b.x - this.x) + b.x_size;
		} else {
			new_x = this.x - b.x;
			new_x_size += new_x;
		}

		if( b.y > this.y ) {
			new_y_size = (b.y - this.y) + b.y_size;
		} else {
			new_y = this.y - b.y;
			new_y_size += new_y;
		}
*/
		volume = new_x_size * new_y_size;

		return volume;
	}

	function is_full() {
		if( this.children.length == this.max_children ) {
			return 1;
		}
		return 0;
	}

	function bulk_load() {

	}
}

function nearest_x(a,b) {
	return a.x-b.x;
}

function nearest_center(a,b) {
	return ((a.x+a.x_size)/2)-((b.x+b.x_size)/2);
}

function pair( a, b ) {
	this.a = a;
	this.b = b;
	this.volume = a.get_volume( b );
}

function QuadraticSplit(a,b) {
	if( a ) {
		if( b ) {
			return a.get_volume( b );
		} else {
			return 1;
		}
	}
	return -1;
}

function camera( o ) {
	this.x = o.x + (o.x_size / 2);
	this.y = o.y + (o.y_size / 2);
	this.x_camera = 300;
	this.y_camera = 300;
	this.x_viewer = 300;
	this.y_viewer = 300;
}

/*
function rectangle() {
	point_a;
	point_b;
	point_c;
	point_d;
	point_center;
	volume;
	height;
	width;
	rotation;


}
*/

function force( x, y, interval, name ) {
	this.x = x;
	this.y = y;
	this.interval = interval;
	this.name = name;

	function vector_multiply( v ) {
		this.x *= v.x;
		this.y *= v.y;
	}

	function cross_product( v ) {

	}

	function dot_product( v ) {
		return (this.x * v.x) + (this.y * v.y);
	}

	function vector_add( v ) {
		this.x += v.x;
		this.y += v.y;
	}
	
	function scaler_multiply( s ) {
		this.x *= s;
		this.y *= s;
	}
}

function mobile( x, y ) {
	this.x = x;
	this.y = y;
	this.x_size = 50;
	this.y_size = 50;
	this.x_center = 25;
	this.y_center = 50;
	//this.radius = (((x_size - x_center)^2) + ((y_size - y_center)^2); // radius of bounding circle (technically it's r^2)
	this.x_speed = 0;
	this.y_speed = 0;
	this.x_accel = 0;
	this.y_accel = 0;
	this.forces = new Array();
	this.forces['drag'] = new force(0,0,0,"drag");
	this.forces['gravity'] = new force(0,0,0,"gravity");
	this.x_force = 0;
	this.y_force = 0;
	this.mass = 1;
	this.bvh;
	this.elasticity = 1;
	this.orientation = 0;
	this.color = "black";

	this.push = push;
	this.move = move;
	this.draw = draw;
	this.collision_check = collision_check;

	function push( fx, fy, name ) {
		var index = this.forces.length;
		this.forces.push( index );
		this.forces[index] = new force( fx/interval, fy/interval, interval, name );
	}

	function move( ) {
		this.forces['drag'].x = -(this.x_speed * wind_resistance)/2;
		this.forces['drag'].y = -(this.y_speed * wind_resistance)/2;
		this.forces['drag'].interval = interval;
		this.forces['gravity'].x = 0;
		this.forces['gravity'].y = gravity * this.mass;
		this.forces['gravity'].interval = interval;
		this.x_force = 0;
		this.y_force = 0;

		for( var i in this.forces ) {
			if( this.forces[i].interval <= 0 ) {
				this.forces[i].x = 0;
				this.forces[i].y = 0;
				this.forces.splice(i,1);
			} else {
				this.forces[i].interval -= interval;
				this.x_force += this.forces[i].x;
				this.y_force += this.forces[i].y;
			}
		}

		if( this.x_force < 1 && this.x_force > -1 ) {
			this.x_force = 0;
		}
		if( this.y_force < 1 && this.y_force > -1 ) {
			this.y_force = 0;
		}
		this.x_accel = (this.x_force / this.mass);
		this.y_accel = (this.y_force / this.mass);
		this.x_speed += (this.x_accel * interval);
		this.y_speed += (this.y_accel * interval);
		this.x += (this.x_speed * interval);
		this.y += (this.y_speed * interval);
		this.collision_check();
	}

	function draw() {
		
		if( this.y_speed > 0 ) {
			this.color = "red";
		} else if( this.y_speed < 0 ) {
			this.color = "blue";
		} else {
			this.color = "green";
		}
		ctx.fillStyle = this.color;
/*
		var k = 0;
		for( var i in this.forces ) {
			ctx.fillText("force " + this.forces[i].name + " (" + this.forces[i].x + ", " + this.forces[i].y + ")", this.x, this.y - ( 10 + (10 * k) ) );
			++k;
		}
		ctx.fillText("speed(" + this.x_speed + ", " + this.y_speed + ")", this.x, this.y - (30 + (10 *k) ) );
		ctx.fillText("accel(" + this.x_accel + ", " + this.y_accel + ")", this.x, this.y - (20 + (10 *k) ) );
		ctx.fillText("force(" + this.x_force + ", " + this.y_force + ")", this.x, this.y - (10 + (10 *k) ) );
*/
		ctx.fillRect( this.x, this.y, this.x_size, this.y_size );	
	}

	function collision_check() {
		this.bvh.remove_me = 1;
		this.bvh.ancestor.remove();
		collider.new_shape( this );
		var new_x = 0;
		var new_y = 0;
		if( this.x < 0 ) {
			this.x = 0;
			if( this.x_speed > 30 || this.x_speed < -30 ) {
				new_x = -(this.x_speed * this.elasticity);
			}
			this.x_speed = 0;
		}
		if( this.x + this.x_size > WIDTH ) {
			this.x = WIDTH - this.x_size;
			if( this.x_speed > 30 || this.x_speed < -30 ) {
				new_x = -(this.x_speed * this.elasticity);
			}
			this.x_speed = 0;
		}
		if( this.y < 0 ) {
			this.y = 0;
			if( this.y_speed > 30 || this.y_speed < -30 ) {
				new_y = -(this.y_speed * this.elasticity);
			}
			this.y_speed = 0;
		}
		if( this.y + this.y_size > HEIGHT ) {
			this.y = HEIGHT - this.y_size;
			if( this.y_speed > 30 || this.y_speed < -30 ) {
				new_y = -(this.y_speed * this.elasticity);
			}
			this.y_speed = 0;
		}
		if( new_x != 0 || new_y != 0 ) {
			this.push( -this.x_force*interval, -this.y_force*interval, "counter" );
			this.push( new_x, new_y, "collide" );
		}
	}
	
	function collide( b , x, y ) {

	}

}

function text() {
	this.x = 0;
	this.y = 0;
	this.x_size = 100;
	this.y_size = 50;
	this.text = "";

	this.draw = draw;
	function draw() {
		/*
		ctx.fillStyle = "green";
		ctx.fillRect( this.x, this.y, this.x_size, this.y_size );
		ctx.fillStyle = "black";
		ctx.fillText( this.text, this.x, this.y );
		*/
	}
}
	

init();
window.addEventListener( 'keydown', do_key_down, true );
window.addEventListener( 'keypress', do_key_press, true );
window.addEventListener( 'mousedown', do_mouse_down, true );
window.addEventListener( 'mousemove', do_mouse_move, true );
window.addEventListener( 'mouseup', do_mouse_up, true );
</script>
</head>
<body>

